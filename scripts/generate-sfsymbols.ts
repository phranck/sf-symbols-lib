import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

// Constants for variants
const VARIANTS = ['hierarchical', 'monochrome'] as const;

type Variant = typeof VARIANTS[number];

/**
 * Convert kebab-case and dot-notation to PascalCase with SF prefix
 * e.g., "checkmark-circle-fill" -> "SFCheckmarkCircleFill"
 * e.g., "square.and.arrow.down.on.square" -> "SFSquareAndArrowDownOnSquare"
 * e.g., "0.circle.fill" -> "SF0CircleFill"
 */
function kebabToPascalCase(kebabStr: string): string {
  const result = kebabStr
    .split(/[-.]/)
    .filter(word => word.length > 0)
    .map(word => {
      if (/^\d+$/.test(word)) return word;
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join('');

  // Add SF prefix (no need for N prefix since SF makes it a valid identifier)
  return 'SF' + result;
}

/**
 * Extract SVG viewBox from file
 */
function extractViewBox(svgPath: string): string {
  const content = fs.readFileSync(svgPath, 'utf-8');
  const viewBoxMatch = content.match(/viewBox="([^"]*)"/);
  return viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';
}

/**
 * Extract SVG content from file, removing XML declaration and comments
 */
function extractSvgContent(svgPath: string): string {
  let content = fs.readFileSync(svgPath, 'utf-8');

  content = content.replace(/<\?xml[^?]*\?>/g, '').trim();
  content = content.replace(/<!DOCTYPE[^>]*>/g, '').trim();
  content = content.replace(/<!--[\s\S]*?-->/g, '').trim();
  content = content.replace(/>\s+</g, '><');
  content = content.replace(/fill="(white|black|#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})"/g, 'fill="currentColor"');

  const svgMatch = content.match(/<svg[^>]*>([\s\S]*?)<\/svg>/);
  return svgMatch ? svgMatch[1].trim() : content;
}

/**
 * Ensure directory exists
 */
function ensureDir(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Generate sf-symbol-name.ts with enum and constants
 */
function generateSymbolNameFile(componentsDir: string, symbolFileNames: string[]): void {
  const sortedNames = symbolFileNames.sort();

  const enumEntries = sortedNames
    .map(fileName => {
      const pascalName = kebabToPascalCase(fileName);
      return `  ${pascalName} = '${fileName}',`;
    })
    .join('\n');

  // Generate individual constant exports
  const constantExports = sortedNames
    .map(fileName => {
      const pascalName = kebabToPascalCase(fileName);
      const exportLine = `export const ${pascalName} = SFSymbolName.${pascalName};`;
      return pascalName === 'Infinity' ? `// eslint-disable-next-line no-shadow-restricted-names\n${exportLine}` : exportLine;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbol Names
 *
 * SOURCE OF TRUTH: This enum is generated directly from SVG filenames.
 *
 * Generated by: scripts/generate-sfsymbols.ts
 * DO NOT EDIT MANUALLY
 */

export enum SFSymbolName {
${enumEntries}
}

export type SFSymbolNameType = \`\${SFSymbolName}\`;

/**
 * Individual symbol name constants for convenient imports
 */
${constantExports}

/**
 * Get all available symbol values as an array
 */
export function getAvailableSymbols(): string[] {
  return Object.values(SFSymbolName);
}

/**
 * Check if a symbol value is available
 */
export function isAvailableSymbol(symbolValue: string): boolean {
  return Object.values(SFSymbolName).includes(symbolValue as SFSymbolName);
}
`;

  const filePath = path.join(componentsDir, 'sf-symbol-name.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`‚úÖ CREATED: sf-symbol-name.ts with ${sortedNames.length} symbols`);
}

/**
 * Generate a single variant data file
 */
function generateVariantDataFile(
  outputDir: string,
  variant: Variant,
  symbolData: Record<string, { content: string; viewBox: string }>
): void {
  const entries = Object.entries(symbolData)
    .map(([pascalName, { content }]) => {
      const escapedContent = content.replace(/'/g, "\\'").replace(/\n/g, ' ').replace(/\s+/g, ' ');
      return `  [SFSymbolName.${pascalName}]: '${escapedContent}',`;
    })
    .join('\n');

  const viewBoxEntries = Object.entries(symbolData)
    .map(([pascalName, { viewBox }]) => {
      return `  [SFSymbolName.${pascalName}]: '${viewBox}',`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Data - ${variant}
 *
 * Generated by: scripts/generate-sfsymbols.ts
 * DO NOT EDIT MANUALLY
 */

import { SFSymbolName } from '@/components/sf-symbol-name';

export const sfSymbolsData: Record<SFSymbolName, string> = {
${entries}
};

export const sfSymbolsViewBox: Record<SFSymbolName, string> = {
${viewBoxEntries}
};
`;

  const dirPath = path.join(outputDir, variant);
  ensureDir(dirPath);
  const filePath = path.join(dirPath, 'data.ts');
  fs.writeFileSync(filePath, fileContent);
}

/**
 * Generate entry point for a variant
 */
function generateVariantEntryPoint(
  outputDir: string,
  variant: Variant
): void {
  const fileContent = `/**
 * SF Symbols - ${variant}
 *
 * Usage:
 * import { SFSymbol, Checkmark, CheckmarkCircleFill } from 'sf-symbols-lib/${variant}';
 *
 * <SFSymbol name={Checkmark} />
 *
 * Generated by: scripts/generate-sfsymbols.ts
 * DO NOT EDIT MANUALLY
 */

// Re-export all symbol names and constants
export * from '@/components/sf-symbol-name';

export { default as SFSymbol } from '@/common/SFSymbol';
`;

  const dirPath = path.join(outputDir, variant);
  ensureDir(dirPath);
  const filePath = path.join(dirPath, 'index.tsx');
  fs.writeFileSync(filePath, fileContent);
  console.log(`‚úÖ CREATED: ${variant}/index.tsx`);
}

/**
 * Generate main index.ts that re-exports everything
 */
function generateMainIndex(srcDir: string): void {
  const fileContent = `/**
 * SF Symbols Library
 *
 * For optimized bundle size, import from a specific variant:
 * import { SFSymbol, Checkmark } from 'sf-symbols-lib/hierarchical';
 *
 * This main entry re-exports from hierarchical as default.
 *
 * Generated by: scripts/generate-sfsymbols.ts
 * DO NOT EDIT MANUALLY
 */

// Re-export from default variant (hierarchical)
export * from './hierarchical';

// Export types
export { SFSymbolVariant } from './types/symbol-types';
export { SFSymbolSize } from './types/sizes';
`;

  const filePath = path.join(srcDir, 'index.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`‚úÖ CREATED: index.ts (default: hierarchical)`);
}

/**
 * Update README.md with current symbol count badge
 */
function updateReadmeBadge(symbolCount: number): void {
  const readmePath = path.join(process.cwd(), 'README.md');

  if (!fs.existsSync(readmePath)) {
    console.log('‚ö†Ô∏è  README.md not found, skipping badge update');
    return;
  }

  let content = fs.readFileSync(readmePath, 'utf-8');

  const badgeUrl = `https://img.shields.io/badge/SF%20Symbols-${symbolCount}-blue?style=flat-square&logo=apple&logoColor=white`;
  const badgeMarkdown = `![SF Symbols](${badgeUrl})`;

  const badgePattern = /!\[SF Symbols\]\([^)]+\)/;
  if (badgePattern.test(content)) {
    content = content.replace(badgePattern, badgeMarkdown);
  }

  fs.writeFileSync(readmePath, content);
  console.log(`‚úÖ UPDATED: README.md badge with ${symbolCount} symbols`);
}

/**
 * Main function to generate SF Symbols
 */
async function generateSFSymbols() {
  const svgsDir = path.join(process.cwd(), '.svgs');
  const srcDir = path.join(process.cwd(), 'src');
  const componentsDir = path.join(srcDir, 'components');

  // Check if svgs directory exists with the new structure
  const hierarchicalDir = path.join(svgsDir, 'hierarchical');
  if (!fs.existsSync(hierarchicalDir)) {
    console.log(`‚ùå ERROR: Expected directory structure not found: ${hierarchicalDir}`);
    return;
  }

  // Get all symbol file names
  const symbolFileNames = fs.readdirSync(hierarchicalDir)
    .filter(file => file.endsWith('.svg'))
    .map(file => file.replace('.svg', ''));

  if (symbolFileNames.length === 0) {
    console.log('‚ö†Ô∏è  No SVG files found.');
    return;
  }

  console.log(`\nüîç Found ${symbolFileNames.length} symbols\n`);

  // Generate sf-symbol-name.ts with enum and constants
  generateSymbolNameFile(componentsDir, symbolFileNames);

  // Process each variant
  let totalProcessed = 0;

  for (const variant of VARIANTS) {
    const dirPath = path.join(svgsDir, variant);

    if (!fs.existsSync(dirPath)) {
      console.log(`‚ö†Ô∏è  Directory not found: ${dirPath}`);
      continue;
    }

    const symbolData: Record<string, { content: string; viewBox: string }> = {};

    for (const fileName of symbolFileNames) {
      const svgPath = path.join(dirPath, `${fileName}.svg`);
      const pascalName = kebabToPascalCase(fileName);

      try {
        if (fs.existsSync(svgPath)) {
          const content = extractSvgContent(svgPath);
          const viewBox = extractViewBox(svgPath);
          symbolData[pascalName] = { content, viewBox };
          totalProcessed++;
        }
      } catch (error) {
        console.error(`‚ùå ERROR processing ${svgPath}:`, error instanceof Error ? error.message : error);
      }
    }

    // Generate data file for this variant
    generateVariantDataFile(srcDir, variant, symbolData);

    // Generate entry point for this variant
    generateVariantEntryPoint(srcDir, variant);

    console.log(`‚úì Processed ${variant} (${Object.keys(symbolData).length} symbols)`);
  }

  // Generate main index.ts
  generateMainIndex(srcDir);

  // Update README badge
  updateReadmeBadge(symbolFileNames.length);

  // Generate docs data and preview page
  console.log('\nüìÑ Generating docs data and preview page...');
  execSync('tsx ./scripts/generate-docs-data.ts', { stdio: 'inherit' });

  console.log(`\nüìä Summary: ${symbolFileNames.length} symbols √ó ${VARIANTS.length} variants = ${totalProcessed} SVGs processed\n`);
}

// Run the generator
generateSFSymbols().catch(error => {
  console.error('‚ùå Error generating SF Symbols:', error);
  process.exit(1);
});
