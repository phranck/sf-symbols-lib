import fs from 'fs';
import path from 'path';

/**
 * Convert kebab-case and dot-notation to PascalCase
 * e.g., "checkmark-circle-fill" -> "CheckmarkCircleFill"
 * e.g., "square.and.arrow.down.on.square" -> "SquareAndArrowDownOnSquare"
 * Handles multi-letter abbreviations and numbers correctly
 */
function kebabToPascalCase(kebabStr: string): string {
  return kebabStr
    .split(/[-.]/)
    .filter(word => word.length > 0)
    .map(word => {
      // Handle special cases: numbers stay with preceding letter
      if (/^\d+$/.test(word)) return word;
      // Capitalize first letter, keep rest as-is
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join('');
}

/**
 * Extract SVG viewBox from file
 */
function extractViewBox(svgPath: string): string {
  const content = fs.readFileSync(svgPath, 'utf-8');
  const viewBoxMatch = content.match(/viewBox="([^"]*)"/);
  return viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';
}

/**
 * Extract SVG content from file, removing XML declaration and comments
 */
function extractSvgContent(svgPath: string): string {
  let content = fs.readFileSync(svgPath, 'utf-8');

  // Remove XML declaration
  content = content.replace(/<\?xml[^?]*\?>/g, '').trim();

  // Remove DOCTYPE
  content = content.replace(/<!DOCTYPE[^>]*>/g, '').trim();

  // Remove SVG comments
  content = content.replace(/<!--[\s\S]*?-->/g, '').trim();

  // Remove extra whitespace but preserve meaningful spaces
  content = content.replace(/>\s+</g, '><');

  // Replace hardcoded fill="white" or fill="black" with currentColor for theme support
  // This allows the icons to adapt to light/dark modes
  content = content.replace(/fill="(white|black|#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})"/g, 'fill="currentColor"');

  // Extract the inner SVG content (everything inside <svg> tags)
  const svgMatch = content.match(/<svg[^>]*>([\s\S]*?)<\/svg>/);
  return svgMatch ? svgMatch[1].trim() : content;
}

/**
 * Generate available-symbols.ts with all SVG-based symbol references
 * This is the SOURCE OF TRUTH for available symbols from SVG files
 * Use this enum when mapping section names to symbols
 */
function generateAvailableSymbolsFile(iconsDir: string, svgFileNames: string[]): void {
  const sortedNames = svgFileNames.sort();

  const enumEntries = sortedNames
    .map(fileName => {
      const pascalName = kebabToPascalCase(fileName);
      return `  ${pascalName} = '${fileName}',`;
    })
    .join('\n');

  const fileContent = `/**
 * Available SF Symbols from SVG Files
 * 
 * SOURCE OF TRUTH: This enum is generated directly from SVG filenames in sf-symbols/svgs/
 * All symbol references throughout the app should use keys from this enum.
 * This ensures type-safety and prevents referencing non-existent symbols.
 * 
 * Generated by: scripts/generate-sfsymbols.ts
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next script run
 * 
 * Usage:
 * import { AvailableSFSymbol } from './available-sfsymbols';
 * 
 * // Use in mappings (e.g., section-symbols mapping)
 * const symbolMapping = {
 *   Display: AvailableSFSymbol.Display,  // Type-safe!
 * };
 */

export enum AvailableSFSymbol {
${enumEntries}
}

export type AvailableSFSymbolType = \`\${AvailableSFSymbol}\`;

/**
 * Get all available symbol values as an array
 * Useful for validation and iteration
 */
export function getAvailableSymbols(): string[] {
  return Object.values(AvailableSFSymbol);
}

/**
 * Check if a symbol value is available
 * @param symbolValue The symbol value to check
 * @returns true if the symbol is available, false otherwise
 */
export function isAvailableSymbol(symbolValue: string): boolean {
  return Object.values(AvailableSFSymbol).includes(symbolValue as AvailableSFSymbol);
}
`;

  const filePath = path.join(iconsDir, 'available-sfsymbols.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`\x1b[33m‚úÖ CREATED: available-sfsymbols.ts with ${sortedNames.length} symbols (SOURCE OF TRUTH)\x1b[0m`);
}

/**
 * Generate icons-data.ts file with all SVG contents and viewBox data
 * Uses AvailableSFSymbol enum keys instead of string literals
 */function generateIconsDataFile(iconsDir: string, iconNamesAndContent: Record<string, { content: string; viewBox: string }>): void {
  // Generate SVG content entries using enum values
  const svgEntries = Object.entries(iconNamesAndContent)
    .map(([pascalName, { content }]) => {
      // Escape single quotes and newlines for TypeScript string literal
      const escapedContent = content.replace(/'/g, "\\'").replace(/\n/g, ' ').replace(/\s+/g, ' ');
      return `  [AvailableSFSymbol.${pascalName}]: '${escapedContent}',`;
    })
    .join('\n');

  // Generate viewBox entries using enum values
  const viewBoxEntries = Object.entries(iconNamesAndContent)
    .map(([pascalName, { viewBox }]) => {
      return `  [AvailableSFSymbol.${pascalName}]: '${viewBox}',`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Icons Data
 * 
 * This file is auto-generated by the generate-sf-symbols script.
 * It contains the SVG content and viewBox values for all SF Symbol icons.
 * Uses AvailableSFSymbol enum for type-safe key references.
 * 
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next script run
 */

import { AvailableSFSymbol } from './available-sfsymbols';

export const sfIconsData = {
${svgEntries}
} as const;

export const sfIconsViewBox = {
${viewBoxEntries}
} as const;

export type SFIconName = keyof typeof sfIconsData;
`;

  const filePath = path.join(iconsDir, 'icons-data.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`\x1b[33m‚úÖ CREATED: icons-data.ts with ${Object.keys(iconNamesAndContent).length} icons\x1b[0m`);
}

/**

 * Generate icon-map.ts file with symbol name to component name mapping
 * Maps enum keys to their component export names
 */
function generateIconMapFile(iconsDir: string, iconNames: string[]): void {
  const sortedNames = Array.from(new Set(iconNames)).sort();

  const mapEntries = sortedNames
    .map(pascalName => {
      return `  [AvailableSFSymbol.${pascalName}]: 'SF${pascalName}',`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Icon Map
 * 
 * This file is auto-generated by the generate-sf-symbols script.
 * Maps enum keys to their component export names.
 * Uses AvailableSFSymbol enum for type-safe references.
 * 
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next script run
 * 
 * Usage:
 * import { sfIconMap } from './icons-map';
 * import { SFSymbolName } from './sf-symbols-enum';
 * 
 * const componentName = sfIconMap[AvailableSFSymbol.ServerRack]; // Returns 'SFServerRack'
 */

import { AvailableSFSymbol } from './available-sfsymbols';

export const sfIconMap = {
${mapEntries}
} as const;

export type SFIconMapKey = keyof typeof sfIconMap;
`;

  const filePath = path.join(iconsDir, 'icons-map.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`\x1b[33m‚úÖ CREATED: icons-map.ts with ${sortedNames.length} mappings\x1b[0m`);
}

/**
 * Generate index.tsx file with all icon exports
 * Uses AvailableSFSymbol enum values for type-safe references
 */
function generateIndexFile(iconsDir: string, iconNames: string[]): void {
  const sortedNames = Array.from(new Set(iconNames)).sort();

  const imports = `import { AvailableSFSymbol } from './available-sfsymbols';
import { createSFIcon } from './SFIcon';`;

  const exports = sortedNames
    .map(pascalName => {
      return `export const SF${pascalName} = createSFIcon(AvailableSFSymbol.${pascalName});`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Icon Library - Index File
 * 
 * This file is auto-generated by the generate-sf-symbols script.
 * It exports all SF Symbol icon components for easy importing.
 * Uses SFSymbolName enum for type-safe icon references.
 * 
 * Usage:
 * import { SFCheckmark, SFCircle } from '../sf-symbols';
 */

${imports}

${exports}
`;

  const filePath = path.join(iconsDir, 'index.tsx');
  fs.writeFileSync(filePath, fileContent);
  console.log(`üìù Generated: index.tsx with ${sortedNames.length} exports`);
}

/**
 * Main function to generate SF Icons from SVG files
 */
async function generateSFIcons() {
  const rawIconsDir = path.join(process.cwd(), 'svgs');
  const iconsDir = path.join(process.cwd(), 'src/components');

  // Check if raw icons directory exists
  if (!fs.existsSync(rawIconsDir)) {
    console.log(`üìÅ Creating directory: ${rawIconsDir}`);
    fs.mkdirSync(rawIconsDir, { recursive: true });
    console.log('‚ÑπÔ∏è  Please add your SVG files to this directory and run this script again.');
    return;
  }

  // Get all SVG files
  const svgFiles = fs.readdirSync(rawIconsDir).filter(file => file.endsWith('.svg'));

  if (svgFiles.length === 0) {
    console.log('‚ö†Ô∏è  No SVG files found in svgs directory.');
    console.log('‚ÑπÔ∏è  Checking for existing generated files...');

    // Try to read existing available-sfsymbols.ts to get current count
    const existingEnumFile = path.join(iconsDir, 'available-sfsymbols.ts');
    if (fs.existsSync(existingEnumFile)) {
      const content = fs.readFileSync(existingEnumFile, 'utf-8');
      const enumMatch = content.match(/export enum AvailableSFSymbol \{([^}]+)\}/);
      if (enumMatch) {
        const enumLines = enumMatch[1].trim().split('\n').filter(line => line.trim());
        const iconCount = enumLines.length;
        console.log(`üìä Found ${iconCount} existing symbols in generated files`);
        updateReadmeBadge(iconCount);
        return;
      }
    }

    console.log('‚ö†Ô∏è  No existing generated files found either.');
    updateReadmeBadge(0);
    return;
  }

  console.log(`\nüîç Found ${svgFiles.length} SVG file(s)\n`);

  const iconNamesAndContent: Record<string, { content: string; viewBox: string }> = {};

  svgFiles.forEach(svgFile => {
    const iconName = kebabToPascalCase(svgFile.replace('.svg', ''));
    const svgPath = path.join(rawIconsDir, svgFile);

    try {
      const svgContent = extractSvgContent(svgPath);
      const viewBox = extractViewBox(svgPath);
      iconNamesAndContent[iconName] = { content: svgContent, viewBox };
      console.log(`\x1b[33m‚úÖ PROCESSED: ${svgFile} ‚Üí ${iconName}\x1b[0m`);
    } catch (error) {
      console.error(`‚ùå ERROR processing ${svgFile}:`, error instanceof Error ? error.message : error);
    }
  });

  // Generate files
  // First, generate available symbols (SOURCE OF TRUTH from SVG files)
  generateAvailableSymbolsFile(iconsDir, svgFiles.map(f => f.replace('.svg', '')));
  
  // Then generate other files (don't generate duplicate sf-symbols-enum.ts)
  generateIconsDataFile(iconsDir, iconNamesAndContent);
  generateIndexFile(iconsDir, Object.keys(iconNamesAndContent));
  generateIconMapFile(iconsDir, Object.keys(iconNamesAndContent));

  // Update README badge with icon count
  updateReadmeBadge(Object.keys(iconNamesAndContent).length);

  console.log(`\nüìä Summary: ${Object.keys(iconNamesAndContent).length} icons processed\n`);
}

/**
 * Update README.md with current icon count badge
 */
function updateReadmeBadge(iconCount: number): void {
  const readmePath = path.join(process.cwd(), 'README.md');

  if (!fs.existsSync(readmePath)) {
    console.log('‚ö†Ô∏è  README.md not found, skipping badge update');
    return;
  }

  let content = fs.readFileSync(readmePath, 'utf-8');

  // Create badge URL
  const badgeUrl = `https://img.shields.io/badge/SF%20Symbols-${iconCount}-blue?style=flat-square&logo=apple&logoColor=white`;
  const badgeMarkdown = `![SF Symbols](${badgeUrl})\n\n`;

  // Replace existing badge or add new one after the title
  const badgePattern = /!\[SF Symbols\]\([^)]+\)\n\n/;
  if (badgePattern.test(content)) {
    // Replace existing badge
    content = content.replace(badgePattern, badgeMarkdown);
  } else {
    // Add badge after title
    const titlePattern = /^# SF Symbols Library\n\nA React component library for SF Symbols icons\.\n\n/;
    if (titlePattern.test(content)) {
      content = content.replace(
        titlePattern,
        `# SF Symbols Library\n\nA React component library for SF Symbols icons.\n\n${badgeMarkdown}`
      );
    } else {
      // Fallback: add at the beginning
      content = `# SF Symbols Library\n\n${badgeMarkdown}A React component library for SF Symbols icons.\n\n` + content.substring(content.indexOf('\n\n') + 2);
    }
  }

  fs.writeFileSync(readmePath, content);
  console.log(`\x1b[33m‚úÖ UPDATED: README.md badge with ${iconCount} symbols\x1b[0m`);
}

// Run the generator
generateSFIcons().catch(error => {
  console.error('‚ùå Error generating SF Icons:', error);
  process.exit(1);
});
