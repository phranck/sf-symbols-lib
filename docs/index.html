<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SF Symbols — Demo</title>

    <!-- Google Font: Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Bootstrap CSS -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">

    <!-- Preload CSS for optimal caching -->
    <link rel="preload" href="styles/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="styles/drawer.css" as="style" onload="this.onload=null;this.rel='stylesheet'">

  </head>
  <body>
    <!-- Fixed header -->
    <header class="frosted-header" style="position:fixed; top:0; left:0; right:0; z-index:1030;">
      <div class="header-top">
        <div class="header-title">
          <h1 class="h4 mb-0">SF Symbols Library Preview</h1>
          <div class="subtext small">Interactive preview of all available SF Symbols</div>
        </div>
        <div class="header-controls">
          <div style="position:relative; display:flex; align-items:center; gap:0.5rem;">
            <div class="input-group" style="max-width:720px; width:100%;">
              <input id="symbols-search" class="search-input form-control" type="search" placeholder="Search symbols..." aria-label="Search symbols">
              <button id="search-help-button" class="btn btn-outline-secondary" type="button" aria-label="Search help" title="Search help">
                <i class="bi bi-info-circle" aria-hidden="true" style="font-size:16px; line-height:1;"></i>
              </button>
            </div>
            <div id="search-help-popover" class="search-help-popover" role="dialog" aria-hidden="true">
              <!-- SEARCH_CONTENT -->
            </div>
          </div>
          <button id="theme-toggle" class="theme-toggle" aria-pressed="false" aria-label="Toggle theme">
            <span id="theme-toggle-icon"></span>
          </button>
          <button id="about-button" class="theme-toggle" aria-haspopup="dialog" aria-controls="about-modal" aria-label="About">
            <span id="about-button-icon"><i class="bi bi-info-square" aria-hidden="true" style="font-size:18px; line-height:1;"></i></span>
          </button>
        </div>
      </div>

      <div class="header-controls">
        <div class="control-group">
          <label class="control-label" for="variant-select">Variant</label>
          <select id="variant-select" class="control-select">
            <option value="hierarchical" selected>Hierarchical</option>
            <option value="monochrome">Monochrome</option>
          </select>
        </div>

        <div class="control-group">
          <label class="control-label" for="color-selector">Color</label>
          <div class="color-selector" id="color-selector">
            <div class="color-selected" id="color-selected"></div>
            <div class="color-dropdown" id="color-dropdown">
              <div class="color-grid">
                <!-- Colors will be added by JavaScript -->
              </div>
            </div>
          </div>
        </div>

        <div class="stats-bar" style="margin-left: auto;">
          <div class="stat-item">
            <span>Showing:</span>
            <span id="visible-count" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span>Total:</span>
            <span id="total-count" class="stat-value">0</span>
          </div>
        </div>
      </div>
    </header>



    <main class="container-fluid" style="padding-top: 160px; padding-bottom: 2rem; padding-left: 2rem; padding-right: 2rem;">
      <section id="icons">
        <!-- Symbols will be injected here -->
      </section>
    </main>

    <footer class="site-footer mt-5 small">
      <div>Made with ❤️ by <a href="https://layered.work" target="_blank" rel="noopener noreferrer">LAYERED</a></div>
    </footer>

    <!-- Toast notification -->
    <div id="sf-toast" class="sf-toast" role="status" aria-live="polite" hidden></div>

    <script type="module">
      // Elements
      const themeToggleButton = document.getElementById('theme-toggle');
      const themeToggleIcon = document.getElementById('theme-toggle-icon');
      const bottomDrawer = document.createElement('aside');
      bottomDrawer.id = 'bottom-drawer';
      bottomDrawer.setAttribute('aria-hidden', 'true');
      bottomDrawer.innerHTML = `<div id="drawer-content" class="drawer-content"></div>`;
      document.body.appendChild(bottomDrawer);
      bottomDrawer.addEventListener('wheel', (e) => {
        if (!e.target.closest('.drawer-code')) {
          e.preventDefault();
        }
      });

      // Load info symbols list
      const infoSymbolsArray = ["accessibility","accessibility.badge.arrow.up.right","accessibility.fill","airplay.audio","airplay.audio.badge.exclamationmark","airplay.audio.circle","airplay.audio.circle.fill","airplay.video","airplay.video.badge.exclamationmark","airplay.video.circle","airplay.video.circle.fill","airpod.gen3.left","airpod.gen3.right","airpod.left","airpod.right","airpods","airpods.chargingcase","airpods.chargingcase.fill","airpods.chargingcase.wireless","airpods.chargingcase.wireless.fill","airpods.gen3","airpods.gen3.chargingcase.wireless","airpods.gen3.chargingcase.wireless.fill","airpods.gen4","airpods.gen4.chargingcase.wireless","airpods.gen4.chargingcase.wireless.fill","airpods.gen4.left","airpods.gen4.right","airpods.max","airpods.pro","airpods.pro.chargingcase.wireless","airpods.pro.chargingcase.wireless.fill","airpods.pro.chargingcase.wireless.radiowaves.left.and.right","airpods.pro.chargingcase.wireless.radiowaves.left.and.right.fill","airpods.pro.left","airpods.pro.right","airport.express","airport.extreme","airport.extreme.tower","airtag","airtag.fill","airtag.radiowaves.forward","airtag.radiowaves.forward.fill","appclip","apple.haptics.and.exclamationmark.triangle","apple.haptics.and.music.note","apple.haptics.and.music.note.slash","apple.homekit","apple.image.playground","apple.image.playground.fill","apple.intelligence","apple.intelligence.badge.xmark","apple.logo","apple.meditate","apple.meditate.circle","apple.meditate.circle.fill","apple.meditate.square.stack","apple.meditate.square.stack.fill","apple.writing.tools","applepencil","applepencil.adapter.usb.c","applepencil.adapter.usb.c.fill","applepencil.and.scribble","applepencil.doubletap","applepencil.gen1","applepencil.gen2","applepencil.hover","applepencil.squeeze","applepencil.tip","applescript","applescript.fill","appletv","appletv.badge.checkmark","appletv.badge.checkmark.fill","appletv.badge.exclamationmark","appletv.badge.exclamationmark.fill","appletv.fill","appletvremote.gen1","appletvremote.gen1.fill","appletvremote.gen2","appletvremote.gen2.fill","appletvremote.gen3","appletvremote.gen3.fill","appletvremote.gen4","appletvremote.gen4.fill","applewatch","applewatch.and.arrow.forward","applewatch.badge.checkmark","applewatch.badge.exclamationmark","applewatch.case.sizes","applewatch.radiowaves.left.and.right","applewatch.side.right","applewatch.slash","applewatch.watchface","apps.ipad","apps.ipad.badge.checkmark","apps.ipad.badge.plus","apps.ipad.landscape","apps.ipad.on.rectangle.portrait.dashed","apps.iphone","apps.iphone.badge.checkmark","apps.iphone.badge.plus","apps.iphone.landscape","arkit","arkit.badge.xmark","arrow.down.applewatch","arrow.down.left.video","arrow.down.left.video.fill","arrow.down.message","arrow.down.message.fill","arrow.trianglehead.2.clockwise.rotate.90.icloud","arrow.trianglehead.2.clockwise.rotate.90.icloud.fill","arrow.trianglehead.clockwise.icloud","arrow.trianglehead.clockwise.icloud.fill","arrow.trianglehead.counterclockwise.icloud","arrow.trianglehead.counterclockwise.icloud.fill","arrow.up.message","arrow.up.message.fill","arrow.up.right.video","arrow.up.right.video.fill","beats.earphones","beats.fitpro","beats.fitpro.chargingcase","beats.fitpro.chargingcase.fill","beats.fitpro.left","beats.fitpro.right","beats.headphones","beats.pill","beats.pill.fill","beats.powerbeats","beats.powerbeats3","beats.powerbeats3.left","beats.powerbeats3.right","beats.powerbeats.left","beats.powerbeats.pro","beats.powerbeats.pro.2","beats.powerbeats.pro.2.chargingcase","beats.powerbeats.pro.2.chargingcase.fill","beats.powerbeats.pro.2.left","beats.powerbeats.pro.2.right","beats.powerbeats.pro.chargingcase","beats.powerbeats.pro.chargingcase.fill","beats.powerbeats.pro.left","beats.powerbeats.pro.right","beats.powerbeats.right","beats.solobuds","beats.solobuds.chargingcase","beats.solobuds.chargingcase.fill","beats.solobuds.left","beats.solobuds.right","beats.studiobuds","beats.studiobuds.chargingcase","beats.studiobuds.chargingcase.fill","beats.studiobuds.left","beats.studiobuds.plus","beats.studiobuds.plus.chargingcase","beats.studiobuds.plus.chargingcase.fill","beats.studiobuds.plus.left","beats.studiobuds.plus.right","beats.studiobuds.right","bolt.horizontal.icloud","bolt.horizontal.icloud.fill","bonjour","candybarphone","checkmark.applewatch","checkmark.icloud","checkmark.icloud.fill","checkmark.message","checkmark.message.fill","deskview","deskview.fill","digitalcrown.arrow.clockwise","digitalcrown.arrow.clockwise.fill","digitalcrown.arrow.counterclockwise","digitalcrown.arrow.counterclockwise.fill","digitalcrown.horizontal.arrow.clockwise","digitalcrown.horizontal.arrow.clockwise.fill","digitalcrown.horizontal.arrow.counterclockwise","digitalcrown.horizontal.arrow.counterclockwise.fill","digitalcrown.horizontal.press","digitalcrown.horizontal.press.fill","digitalcrown.press","digitalcrown.press.fill","earpods","ellipsis.message","ellipsis.message.fill","environments","environments.circle","environments.circle.fill","environments.fill","environments.slash","environments.slash.circle","environments.slash.circle.fill","environments.slash.fill","exclamationmark.applewatch","exclamationmark.icloud","exclamationmark.icloud.fill","exclamationmark.message","exclamationmark.message.fill","faceid","finder","flipphone","head.profile.arrow.forward.and.vision.pro","hifispeaker.and.appletv","hifispeaker.and.appletv.fill","hifispeaker.and.homepod","hifispeaker.and.homepod.badge.minus","hifispeaker.and.homepod.badge.minus.fill","hifispeaker.and.homepod.badge.plus","hifispeaker.and.homepod.badge.plus.fill","hifispeaker.and.homepod.fill","hifispeaker.and.homepod.mini","hifispeaker.and.homepod.mini.badge.minus","hifispeaker.and.homepod.mini.badge.minus.fill","hifispeaker.and.homepod.mini.badge.plus","hifispeaker.and.homepod.mini.badge.plus.fill","hifispeaker.and.homepod.mini.fill","homepod","homepod.2","homepod.2.badge.minus","homepod.2.badge.minus.fill","homepod.2.badge.plus","homepod.2.badge.plus.fill","homepod.2.fill","homepod.and.appletv","homepod.and.appletv.fill","homepod.and.homepod.mini","homepod.and.homepod.mini.badge.minus","homepod.and.homepod.mini.badge.minus.fill","homepod.and.homepod.mini.badge.plus","homepod.and.homepod.mini.badge.plus.fill","homepod.and.homepod.mini.fill","homepod.arrow.forward","homepod.arrow.forward.fill","homepod.badge.checkmark","homepod.badge.checkmark.fill","homepod.badge.minus","homepod.badge.minus.fill","homepod.badge.plus","homepod.badge.plus.fill","homepod.fill","homepod.mini","homepod.mini.2","homepod.mini.2.badge.minus","homepod.mini.2.badge.minus.fill","homepod.mini.2.badge.plus","homepod.mini.2.badge.plus.fill","homepod.mini.2.fill","homepod.mini.and.appletv","homepod.mini.and.appletv.fill","homepod.mini.arrow.forward","homepod.mini.arrow.forward.fill","homepod.mini.badge.checkmark","homepod.mini.badge.checkmark.fill","homepod.mini.badge.minus","homepod.mini.badge.minus.fill","homepod.mini.badge.plus","homepod.mini.badge.plus.fill","homepod.mini.fill","icloud","icloud.and.arrow.down","icloud.and.arrow.down.fill","icloud.and.arrow.up","icloud.and.arrow.up.fill","icloud.circle","icloud.circle.fill","icloud.dashed","icloud.fill","icloud.slash","icloud.slash.fill","icloud.square","icloud.square.fill","inset.filled.applewatch.case","ipad","ipad.badge.checkmark","ipad.badge.exclamationmark","ipad.badge.location","ipad.badge.play","ipad.case","ipad.case.and.iphone.case","ipad.gen1","ipad.gen1.badge.exclamationmark","ipad.gen1.badge.location","ipad.gen1.badge.play","ipad.gen1.crop.homebutton.circle","ipad.gen1.landscape","ipad.gen1.landscape.badge.exclamationmark","ipad.gen1.landscape.badge.location","ipad.gen1.landscape.badge.play","ipad.gen1.landscape.slash","ipad.gen1.sizes","ipad.gen1.slash","ipad.gen2","ipad.gen2.badge.exclamationmark","ipad.gen2.badge.location","ipad.gen2.badge.play","ipad.gen2.landscape","ipad.gen2.landscape.badge.exclamationmark","ipad.gen2.landscape.badge.location","ipad.gen2.landscape.badge.play","ipad.gen2.landscape.slash","ipad.gen2.sizes","ipad.gen2.slash","ipad.landscape","ipad.landscape.and.applewatch","ipad.landscape.and.iphone","ipad.landscape.and.iphone.slash","ipad.landscape.and.ipod","ipad.landscape.badge.exclamationmark","ipad.landscape.badge.location","ipad.landscape.badge.play","ipad.sizes","iphone","iphone.and.arrow.left.and.arrow.right.inward","iphone.and.ipod","iphone.and.vision.pro","iphone.app.switcher","iphone.badge.checkmark","iphone.badge.exclamationmark","iphone.badge.location","iphone.badge.play","iphone.case","iphone.circle","iphone.circle.fill","iphone.crop.circle","iphone.dock.motorized.viewfinder","iphone.gen1","iphone.gen1.and.arrow.left","iphone.gen1.badge.exclamationmark","iphone.gen1.badge.location","iphone.gen1.badge.play","iphone.gen1.circle","iphone.gen1.circle.fill","iphone.gen1.crop.circle","iphone.gen1.crop.homebutton.circle","iphone.gen1.landscape","iphone.gen1.landscape.slash","iphone.gen1.motion","iphone.gen1.radiowaves.left.and.right","iphone.gen1.radiowaves.left.and.right.circle","iphone.gen1.radiowaves.left.and.right.circle.fill","iphone.gen1.sizes","iphone.gen1.slash","iphone.gen1.slash.circle","iphone.gen1.slash.circle.fill","iphone.gen2","iphone.gen2.and.arrow.left.and.arrow.right.inward","iphone.gen2.badge.exclamationmark","iphone.gen2.badge.location","iphone.gen2.badge.play","iphone.gen2.circle","iphone.gen2.circle.fill","iphone.gen2.crop.circle","iphone.gen2.landscape","iphone.gen2.landscape.slash","iphone.gen2.motion","iphone.gen2.radiowaves.left.and.right","iphone.gen2.radiowaves.left.and.right.circle","iphone.gen2.radiowaves.left.and.right.circle.fill","iphone.gen2.sizes","iphone.gen2.slash","iphone.gen2.slash.circle","iphone.gen2.slash.circle.fill","iphone.gen3","iphone.gen3.and.arrow.left.and.arrow.right.inward","iphone.gen3.badge.exclamationmark","iphone.gen3.badge.location","iphone.gen3.badge.play","iphone.gen3.circle","iphone.gen3.circle.fill","iphone.gen3.crop.circle","iphone.gen3.landscape","iphone.gen3.landscape.slash","iphone.gen3.motion","iphone.gen3.radiowaves.left.and.right","iphone.gen3.radiowaves.left.and.right.circle","iphone.gen3.radiowaves.left.and.right.circle.fill","iphone.gen3.sizes","iphone.gen3.slash","iphone.gen3.slash.circle","iphone.gen3.slash.circle.fill","iphone.landscape","iphone.motion","iphone.radiowaves.left.and.right","iphone.radiowaves.left.and.right.circle","iphone.radiowaves.left.and.right.circle.fill","iphone.sizes","iphone.slash","iphone.slash.circle","iphone.slash.circle.fill","iphone.smartbatterycase.gen1","iphone.smartbatterycase.gen2","ipod","ipod.and.applewatch","ipod.and.vision.pro","ipod.shuffle.gen1","ipod.shuffle.gen2","ipod.shuffle.gen3","ipod.shuffle.gen4","ipod.touch","ipod.touch.landscape","ipod.touch.slash","key.icloud","key.icloud.fill","link.icloud","link.icloud.fill","livephoto","livephoto.badge.automatic","livephoto.play","livephoto.slash","lock.applewatch","lock.icloud","lock.icloud.fill","lock.open.applewatch","macbook","macbook.and.applewatch","macbook.and.ipad","macbook.and.iphone","macbook.and.ipod","macbook.and.vision.pro","macbook.badge.checkmark","macbook.badge.exclamationmark","macbook.badge.shield.checkmark","macbook.gen1","macbook.gen1.sizes","macbook.gen2","macbook.gen2.sizes","macbook.sizes","macbook.slash","macbook.trianglebadge.exclamationmark","macmini","macmini.badge.checkmark","macmini.badge.checkmark.fill","macmini.fill","macmini.gen2","macmini.gen2.fill","macmini.gen3","macmini.gen3.fill","macpro.gen1","macpro.gen1.fill","macpro.gen2","macpro.gen2.fill","macpro.gen3","macpro.gen3.badge.ckeckmark","macpro.gen3.badge.ckeckmark.fill","macpro.gen3.fill","macpro.gen3.server","macstudio","macstudio.badge.checkmark","macstudio.badge.checkmark.fill","macstudio.fill","magicmouse","magicmouse.fill","magsafe.batterypack","magsafe.batterypack.fill","matter.logo","message","message.badge","message.badge.circle","message.badge.circle.fill","message.badge.fill","message.badge.filled.fill","message.badge.waveform","message.badge.waveform.fill","message.circle","message.circle.fill","message.fill","opticid","opticid.fill","pencil.tip","pencil.tip.crop.circle","pencil.tip.crop.circle.badge.arrow.forward","pencil.tip.crop.circle.badge.arrow.forward.fill","pencil.tip.crop.circle.badge.minus","pencil.tip.crop.circle.badge.minus.fill","pencil.tip.crop.circle.badge.plus","pencil.tip.crop.circle.badge.plus.fill","pencil.tip.crop.circle.fill","person.2.badge.key","person.2.badge.key.fill","person.badge.key","person.badge.key.fill","person.icloud","person.icloud.fill","person.spatialaudio.3d.fill","person.spatialaudio.fill","person.spatialaudio.stereo.3d.fill","person.spatialaudio.stereo.fill","platter.bottom.applewatch.case","platter.filled.bottom.applewatch.case","platter.filled.top.applewatch.case","platter.top.applewatch.case","playstation.logo","plus.message","plus.message.fill","questionmark.message","questionmark.message.fill","questionmark.video","questionmark.video.fill","safari","safari.fill","sharedwithyou","sharedwithyou.circle","sharedwithyou.circle.fill","sharedwithyou.slash","shareplay","shareplay.slash","shazam.logo","shazam.logo.fill","siri","spatial.capture","spatial.capture.fill","spatial.capture.on.hexagon","spatial.capture.on.hexagon.fill","spatial.capture.slash","spatial.capture.slash.fill","swift","swiftdata","teletype","teletype.answer","teletype.answer.circle","teletype.answer.circle.fill","teletype.circle","teletype.circle.fill","text.line.2.summary","text.line.2.summary.badge.xmark","text.line.3.summary","touchid","translate","video","video.badge.checkmark","video.badge.ellipsis","video.badge.plus","video.badge.waveform","video.badge.waveform.fill","video.bubble","video.bubble.fill","video.circle","video.circle.fill","video.fill","video.fill.badge.checkmark","video.fill.badge.ellipsis","video.fill.badge.plus","video.slash","video.slash.circle","video.slash.circle.fill","video.slash.fill","video.square","video.square.fill","vision.pro","vision.pro.and.arrow.forward","vision.pro.and.arrow.forward.fill","vision.pro.badge.checkmark","vision.pro.badge.checkmark.fill","vision.pro.badge.exclamationmark","vision.pro.badge.exclamationmark.fill","vision.pro.badge.play","vision.pro.badge.play.fill","vision.pro.circle","vision.pro.circle.fill","vision.pro.fill","vision.pro.slash","vision.pro.slash.circle","vision.pro.slash.circle.fill","vision.pro.slash.fill","vision.pro.trianglebadge.exclamationmark","vision.pro.trianglebadge.exclamationmark.fill","voiceover","watchface.applewatch.case","xbox.logo","xmark.icloud","xmark.icloud.fill","xserve","xserve.raid"];
      let infoSymbols = new Set(infoSymbolsArray);
      const searchInput = document.getElementById('symbols-search');
      const searchHelpButton = document.getElementById('search-help-button');
      const searchHelpPopover = document.getElementById('search-help-popover');
      const variantSelect = document.getElementById('variant-select');
      const iconsContainer = document.getElementById('icons');
      const visibleCountEl = document.getElementById('visible-count');
      const totalCountEl = document.getElementById('total-count');
      const sfToastElement = document.getElementById('sf-toast');

      let currentData = {};
      let currentViewBox = {};
      let allSymbolsData = globalThis.allSymbolsData || {};
      let allViewBoxData = globalThis.allViewBoxData || {};
      let selectedSymbolKey = null;
      let focusedIndex = -1;  // Keyboard navigation focus index (-1 = no focus)

      // Keyboard navigation helper functions
      function getVisibleCards() {
        return Array.from(document.querySelectorAll('#icons .card'));
      }

      function setFocusedCard(index) {
        const cards = getVisibleCards();
        // Remove old focus
        cards.forEach(card => card.classList.remove('focused'));

        if (index >= 0 && index < cards.length) {
          focusedIndex = index;
          const card = cards[index];
          card.classList.add('focused');
          // Auto-scroll into visible area
          card.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } else {
          focusedIndex = -1;
        }
      }

      function getGridColumns() {
        const container = document.getElementById('icons');
        const style = getComputedStyle(container);
        const columns = style.gridTemplateColumns.split(' ').length;
        return columns;
      }

      function getCenteredCardIndex() {
        const cards = getVisibleCards();
        if (cards.length === 0) return 0;

        const viewportCenterY = window.scrollY + window.innerHeight / 2;
        const viewportCenterX = window.innerWidth / 2;

        let closestIndex = 0;
        let closestDistance = Infinity;

        cards.forEach((card, index) => {
          const rect = card.getBoundingClientRect();
          const cardCenterX = rect.left + rect.width / 2;
          const cardCenterY = rect.top + window.scrollY + rect.height / 2;

          const distance = Math.hypot(cardCenterX - viewportCenterX, cardCenterY - viewportCenterY);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestIndex = index;
          }
        });

        return closestIndex;
      }

      // Performance tuning
      const FLIP_MEASURE_THRESHOLD = 300; // only run expensive FLIP measurements for small sets

      /**
       * Simple debounce helper to avoid re-rendering on every keystroke
       */
      function debounce(func, wait = 150) {
        let timeoutId = null;
        return function debounced(...args) {
          if (timeoutId) clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(this, args), wait);
        };
      }

      // Theme management
      function applyTheme(mode) {
        const header = document.querySelector('.frosted-header');
        // Add temporary class to suppress transitions/animations during theme switch
        document.body.classList.add('theme-switching');

        // Toggle classes on next frame to avoid triggering transitions
        requestAnimationFrame(() => {
          if (mode === 'dark') {
            document.body.classList.add('dark-mode');
            if (header) header.classList.add('dark');
          } else {
            document.body.classList.remove('dark-mode');
            if (header) header.classList.remove('dark');
          }
          localStorage.setItem('sf-theme', mode);
          themeToggleButton.setAttribute('aria-pressed', mode === 'dark' ? 'true' : 'false');
          updateThemeIcon(mode);

          // Remove the suppression class shortly after to re-enable transitions
          requestAnimationFrame(() => {
            setTimeout(() => document.body.classList.remove('theme-switching'), 120);
          });
        });
      }

      function updateThemeIcon(mode) {
        // Use Bootstrap Icons for theme toggle: moon-stars (dark) and sun (light)
        if (mode === 'dark') {
          themeToggleIcon.innerHTML = '<i class="bi bi-moon-stars" aria-hidden="true" style="font-size:18px; line-height:1;"></i>';
        } else {
          themeToggleIcon.innerHTML = '<i class="bi bi-sun" aria-hidden="true" style="font-size:18px; line-height:1;"></i>';
        }
      }

      // (drawer icon removed) - previously tried to render `filemenu.and.selection`

      // Initialize theme
      const savedTheme = localStorage.getItem('sf-theme') || 'light';
      applyTheme(savedTheme);

      themeToggleButton.addEventListener('click', () => {
        const newMode = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
        applyTheme(newMode);
      });

      // About modal: create DOM once and control via show/hide
      const aboutButton = document.getElementById('about-button');
      const aboutModalOverlay = document.createElement('div');
      aboutModalOverlay.className = 'modal-overlay';
      aboutModalOverlay.id = 'about-modal';
      aboutModalOverlay.setAttribute('role', 'dialog');
      aboutModalOverlay.setAttribute('aria-modal', 'true');
      aboutModalOverlay.setAttribute('aria-hidden', 'true');

      const aboutModal = document.createElement('div');
      aboutModal.className = 'about-modal';

      const aboutTitle = document.createElement('h2');
      aboutTitle.textContent = 'SF Symbols Library';

      // Render provided Markdown as HTML inside the about box
      const aboutContent = document.createElement('div');
      aboutContent.className = 'about-content';
      aboutContent.innerHTML = `<!-- ABOUT_CONTENT -->`;

      const okWrap = document.createElement('div');
      okWrap.style.display = 'flex';
      okWrap.style.justifyContent = 'center';
      okWrap.style.marginTop = '12px';

      const okButton = document.createElement('button');
      okButton.className = 'theme-toggle';
      okButton.type = 'button';
      okButton.textContent = 'OK';
      okButton.addEventListener('click', () => closeAboutModal());

      okWrap.appendChild(okButton);

      aboutModal.appendChild(aboutTitle);
      aboutModal.appendChild(aboutContent);
      aboutModal.appendChild(okWrap);

      aboutModalOverlay.appendChild(aboutModal);
      document.body.appendChild(aboutModalOverlay);

      function openAboutModal() {
        aboutModalOverlay.classList.add('show');
        aboutModalOverlay.setAttribute('aria-hidden', 'false');
        // small timeout to ensure transitions can run; focus OK button
        setTimeout(() => okButton.focus(), 60);
      }

      function closeAboutModal() {
        aboutModalOverlay.classList.remove('show');
        aboutModalOverlay.setAttribute('aria-hidden', 'true');
        aboutButton.focus();
      }

      if (aboutButton) {
        aboutButton.addEventListener('click', (ev) => {
          ev.stopPropagation();
          openAboutModal();
        });
      }

      // Close modal on overlay click outside content
      aboutModalOverlay.addEventListener('click', (ev) => {
        if (ev.target === aboutModalOverlay) closeAboutModal();
      });

      // Close modal on Escape
      document.addEventListener('keydown', (event) => {
        if ((event.key === 'Escape' || event.key === 'Esc') && aboutModalOverlay.classList.contains('show')) {
          closeAboutModal();
        }
      });

      // Copy modal: create DOM once and control via show/hide
      const copyModalOverlay = document.createElement('div');
      copyModalOverlay.className = 'modal-overlay';
      copyModalOverlay.id = 'copy-modal';
      copyModalOverlay.setAttribute('role', 'dialog');
      copyModalOverlay.setAttribute('aria-modal', 'true');
      copyModalOverlay.setAttribute('aria-hidden', 'true');

      const copyModal = document.createElement('div');
      copyModal.className = 'copy-modal';

      const copyTitle = document.createElement('h3');
      copyTitle.textContent = 'Copy to Clipboard';

      const copyOptionsContainer = document.createElement('div');
      copyOptionsContainer.className = 'copy-options';

      copyModal.appendChild(copyTitle);
      copyModal.appendChild(copyOptionsContainer);
      copyModalOverlay.appendChild(copyModal);
      document.body.appendChild(copyModalOverlay);

      let copyModalFocusedIndex = 0;
      let copyOptions = [];

      function openCopyModal() {
        if (!selectedSymbolKey) return;

        const displayName = (globalThis.symbolNames || {})[selectedSymbolKey] || selectedSymbolKey;

        // Clear and rebuild options
        copyOptionsContainer.innerHTML = '';
        copyOptions = [];

        // Package Symbol Name option
        const packageOption = document.createElement('div');
        packageOption.className = 'copy-option';
        packageOption.innerHTML = `
          <span class="copy-option-label">Package Symbol Name</span>
          <span class="copy-option-value">${displayName}</span>
        `;
        packageOption.dataset.copyValue = displayName;
        packageOption.addEventListener('click', () => copyAndClose(displayName));
        copyOptionsContainer.appendChild(packageOption);
        copyOptions.push(packageOption);

        // Apple Symbol Name option
        const appleOption = document.createElement('div');
        appleOption.className = 'copy-option';
        appleOption.innerHTML = `
          <span class="copy-option-label">Apple Symbol Name</span>
          <span class="copy-option-value">${selectedSymbolKey}</span>
        `;
        appleOption.dataset.copyValue = selectedSymbolKey;
        appleOption.addEventListener('click', () => copyAndClose(selectedSymbolKey));
        copyOptionsContainer.appendChild(appleOption);
        copyOptions.push(appleOption);

        // React Component option
        const reactOption = document.createElement('div');
        reactOption.className = 'copy-option';
        reactOption.innerHTML = `
          <span class="copy-option-label">React Component</span>
          <span class="copy-option-value">&lt;SFSymbol name={${displayName}} size={32} /&gt;</span>
        `;
        reactOption.dataset.copyValue = `<SFSymbol name={${displayName}} size={32} />`;
        reactOption.addEventListener('click', () => copyAndClose(`<SFSymbol name={${displayName}} size={32} />`));
        copyOptionsContainer.appendChild(reactOption);
        copyOptions.push(reactOption);

        // Reset focus to first option
        copyModalFocusedIndex = 0;
        updateCopyModalFocus();

        copyModalOverlay.classList.add('show');
        copyModalOverlay.setAttribute('aria-hidden', 'false');
      }

      function closeCopyModal() {
        copyModalOverlay.classList.remove('show');
        copyModalOverlay.setAttribute('aria-hidden', 'true');
      }

      function updateCopyModalFocus() {
        copyOptions.forEach((option, index) => {
          option.classList.toggle('focused', index === copyModalFocusedIndex);
        });
      }

      function copyAndClose(text) {
        navigator.clipboard.writeText(text).then(() => {
          closeCopyModal();
          showToast('Copied to clipboard');
        }).catch(() => {
          closeCopyModal();
          showToast('Failed to copy');
        });
      }

      // Close copy modal on overlay click outside content
      copyModalOverlay.addEventListener('click', (event) => {
        if (event.target === copyModalOverlay) closeCopyModal();
      });

      // Copy modal keyboard navigation
      document.addEventListener('keydown', (event) => {
        if (!copyModalOverlay.classList.contains('show')) return;

        switch (event.key) {
          case 'Escape':
          case 'Esc':
            event.preventDefault();
            closeCopyModal();
            break;

          case 'ArrowDown':
            event.preventDefault();
            copyModalFocusedIndex = (copyModalFocusedIndex + 1) % copyOptions.length;
            updateCopyModalFocus();
            break;

          case 'ArrowUp':
            event.preventDefault();
            copyModalFocusedIndex = (copyModalFocusedIndex - 1 + copyOptions.length) % copyOptions.length;
            updateCopyModalFocus();
            break;

          case 'Enter':
            event.preventDefault();
            if (copyOptions[copyModalFocusedIndex]) {
              const text = copyOptions[copyModalFocusedIndex].dataset.copyValue;
              copyAndClose(text);
            }
            break;
        }
      });

      // Toast helper
      let toastTimer = null;
      function showToast(message, duration = 2500) {
        if (!sfToastElement) return;
        sfToastElement.hidden = false;
        sfToastElement.textContent = message;
        sfToastElement.classList.add('show');
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          sfToastElement.classList.remove('show');
          setTimeout(() => { sfToastElement.hidden = true; }, 300);
        }, duration);
      }

      // Render symbols
      function renderSymbols() {
        const query = (searchInput.value || '').trim().toLowerCase();

        // Prepare entries and decide whether to run expensive FLIP measurements
        const entries = Object.entries(currentData);
        const totalEntries = entries.length;
        const existingCards = iconsContainer.querySelectorAll('.card');
        let oldRects = null;
        const shouldMeasureFlip = existingCards.length > 0 && existingCards.length <= FLIP_MEASURE_THRESHOLD && totalEntries <= FLIP_MEASURE_THRESHOLD;
        if (shouldMeasureFlip) {
          oldRects = new Map();
          existingCards.forEach(node => {
            const titleKey = node.title || '';
            oldRects.set(titleKey, node.getBoundingClientRect());
          });
        }

        // Build new content into a DocumentFragment to minimize reflows
        const fragment = document.createDocumentFragment();
        let visibleCount = 0;

        entries.forEach(([key, svgContent]) => {
          const name = (globalThis.symbolNames || {})[key] || key;
          const searchText = (name + ' ' + key).toLowerCase();

          // Advanced search parsing:
          // - '|' splits OR segments: match any segment
          // - within a segment, '&' or whitespace indicates AND: all tokens must match
          if (query) {
            const orSegments = query.split('|').map(s => s.trim()).filter(Boolean);
            // If there are OR segments, a symbol matches if any segment matches
            const matchesOr = orSegments.some(segment => {
              // Split by '&' first, then by whitespace to support both 'a & b' and 'a b'
              const andParts = segment.split('&').map(p => p.trim()).filter(Boolean);
              // Expand whitespace-separated tokens inside each andPart
              const tokens = andParts.flatMap(p => p.split(/\s+/).map(t => t.trim()).filter(Boolean));
              // All tokens in this segment must be present
              return tokens.every(token => searchText.includes(token));
            });
            if (!matchesOr) return;
          }

          visibleCount++;

          const card = document.createElement('div');
          card.className = 'card';
          card.title = name;
          card.dataset.sfKey = key;

          const vb = currentViewBox[key] || '0 0 24 24';
          // Always force fill for consistency
          const shouldForceCardFill = true;
          card.innerHTML = shouldForceCardFill
            ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}" fill="currentColor">${svgContent}</svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">${svgContent}</svg>`;

          // Add info icon for symbols that require attribution
          if (infoSymbols.has(key)) {
            const infoIcon = document.createElement('div');
            infoIcon.className = 'card-info-icon';
            infoIcon.innerHTML = '<i class="bi bi-info-circle-fill" style="color: inherit;" aria-hidden="true"></i>';
            
            // Add click handler directly to the icon
            infoIcon.addEventListener('click', (ev) => {
              ev.stopPropagation();
              
              // Close any existing popovers first
              const existingPopovers = document.querySelectorAll('.popover');
              existingPopovers.forEach(p => p.remove());
              
              // Use Bootstrap popover
              const isDark = document.body.classList.contains('dark-mode');
              const popover = new bootstrap.Popover(infoIcon, {
                content: 'This symbol may not be modified and may only be used to refer to Apple\'s Markup feature.',
                placement: 'top',
                trigger: 'manual',
                animation: true,
                html: false,
                customClass: isDark ? 'popover-dark' : ''
              });
              
              // Show the popover
              popover.show();
              
              // Auto-hide after 6 seconds
              setTimeout(() => {
                popover.hide();
              }, 6000);
            });
            
            card.appendChild(infoIcon);
          }

          card.addEventListener('click', (ev) => {
            // Don't select if clicking on info icon
            if (ev.target.closest('.card-info-icon')) return;

            // Mark selected symbol (no clipboard copy)
            selectedSymbolKey = key;
            // update visuals
            document.querySelectorAll('.card.selected').forEach(node => node.classList.remove('selected'));
            document.querySelectorAll('.card.focused').forEach(node => node.classList.remove('focused'));
            card.classList.add('selected');
            card.classList.add('focused');
            // Update focusedIndex for keyboard navigation
            const cards = getVisibleCards();
            focusedIndex = cards.indexOf(card);
            renderDrawerContent();
            // Open bottom drawer automatically when selecting a symbol
            openDrawer();
          });

          fragment.appendChild(card);
        });

        // Replace nodes
        iconsContainer.innerHTML = '';
        iconsContainer.appendChild(fragment);

        // Reset keyboard focus when grid changes
        focusedIndex = -1;

        // After new nodes are in the DOM, run FLIP if we measured old positions
        if (oldRects) {
          const newNodes = Array.from(iconsContainer.querySelectorAll('.card'));
          newNodes.forEach(node => {
            const titleKey = node.title || '';
            const newRect = node.getBoundingClientRect();
            const oldRect = oldRects.get(titleKey);
            if (oldRect) {
              const deltaX = oldRect.left - newRect.left;
              const deltaY = oldRect.top - newRect.top;
              // Apply inverse transform
              node.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              node.style.transition = 'transform 320ms cubic-bezier(.2,.8,.2,1)';
              // Force reflow then play
              requestAnimationFrame(() => {
                node.style.transform = '';
              });
              // Cleanup after animation
              node.addEventListener('transitionend', function cleanup() {
                node.style.transition = '';
                node.removeEventListener('transitionend', cleanup);
              });
            }
          });
        }

        visibleCountEl.textContent = visibleCount.toLocaleString();
        totalCountEl.textContent = entries.length.toLocaleString();
      }

      // Update data when variant changes
      function updateData() {
        const variant = variantSelect.value;

        currentData = globalThis.allSymbolsData[variant] || {};
        currentViewBox = globalThis.allViewBoxData[variant] || {};

        // Defer heavy rendering to the next animation frame to keep UI responsive
        requestAnimationFrame(() => renderSymbols());
        updateThemeIcon(document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        // Re-render drawer content in case icon keys changed
        renderDrawerContent();
      }

      // Make updateData globally accessible for the loader
      globalThis.updateData = updateData;

      // 42 Color palette (sorted by hex value ascending)
      const colors = [
        '#000000', '#00008B', '#0000FF', '#006400', '#00BFFF', '#00CED1', '#00FF00', '#00FFFF',
        '#1E90FF', '#2F4F4F', '#32CD32', '#696969', '#778899', '#800080', '#808080', '#8B0000',
        '#8FBC8F', '#90EE90', '#98FB98', '#9932CC', '#A52A2A', '#ADD8E6', '#B0C4DE', '#BC8F8F',
        '#C0C0C0', '#CD853F', '#D2691E', '#D3D3D3', '#DDA0DD', '#DEB887', '#F0E68C', '#F5DEB3',
        '#FF0000', '#FF00FF', '#FF1493', '#FF6347', '#FFA500', '#FFC0CB', '#FFD700', '#FFDAB9',
        '#FFFF00', '#FFFFFF'
      ];

      let currentColor = '#000000';

      // Initialize color selector
      function initColorSelector() {
        const colorSelector = document.getElementById('color-selector');
        const colorSelected = document.getElementById('color-selected');
        const colorDropdown = document.getElementById('color-dropdown');
        const colorGrid = colorDropdown.querySelector('.color-grid');
        // Create a theme-aware option that uses CSS `currentColor`.
        // This option makes symbols theme-aware and will be the default on first visit.
        const themeOption = document.createElement('div');
        themeOption.className = 'color-option';
        themeOption.dataset.color = 'currentColor';
        themeOption.title = 'Theme color (currentColor)';
        themeOption.style.display = 'flex';
        themeOption.style.alignItems = 'center';
        themeOption.style.justifyContent = 'center';
        themeOption.style.fontSize = '10px';
        themeOption.style.color = 'inherit';
        themeOption.textContent = 'T';
        if (currentColor === 'currentColor') themeOption.classList.add('selected');
        themeOption.addEventListener('click', () => { selectColor('currentColor'); closeColorDropdown(); });
        colorGrid.appendChild(themeOption);

        // Create color options
        colors.forEach(color => {
          const colorOption = document.createElement('div');
          colorOption.className = 'color-option';
          colorOption.style.backgroundColor = color;
          colorOption.dataset.color = color;

          if (color === currentColor) {
            colorOption.classList.add('selected');
          }

          colorOption.addEventListener('click', () => {
            selectColor(color);
            closeColorDropdown();
          });

          colorGrid.appendChild(colorOption);
        });

        // Toggle dropdown
        colorSelector.addEventListener('click', (e) => {
          e.stopPropagation();
          colorSelector.classList.toggle('open');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!colorSelector.contains(e.target)) {
            closeColorDropdown();
          }
        });

        // Update selected color display
        updateColorDisplay();
      }

      // Search help popover handlers
      if (searchHelpButton && searchHelpPopover) {
        searchHelpButton.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const willShow = !searchHelpPopover.classList.contains('show');
          if (willShow) {
            searchHelpPopover.classList.add('show');
            searchHelpPopover.setAttribute('aria-hidden', 'false');
          } else {
            searchHelpPopover.classList.remove('show');
            searchHelpPopover.setAttribute('aria-hidden', 'true');
          }
        });

        // Clicking outside closes the popover
        document.addEventListener('click', (ev) => {
          if (!searchHelpPopover.classList.contains('show')) return;
          if (searchHelpPopover.contains(ev.target) || searchHelpButton.contains(ev.target)) return;
          searchHelpPopover.classList.remove('show');
          searchHelpPopover.setAttribute('aria-hidden', 'true');
        });

        // Close popover on Escape
        document.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape' || ev.key === 'Esc') {
            if (searchHelpPopover.classList.contains('show')) {
              searchHelpPopover.classList.remove('show');
              searchHelpPopover.setAttribute('aria-hidden', 'true');
            }
          }
        });
      }

      // Close popover when clicking outside
      document.addEventListener('click', (ev) => {
        // Close popovers if clicking outside of info icons and popovers
        if (!ev.target.closest('.card-info-icon') && !ev.target.closest('.popover')) {
          const existingPopovers = document.querySelectorAll('.popover');
          existingPopovers.forEach(p => {
            const popover = bootstrap.Popover.getInstance(p.previousElementSibling);
            if (popover) popover.hide();
          });
        }
      });

      // Close info popover on Escape
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' || ev.key === 'Esc') {
          if (infoSymbolPopover.classList.contains('show')) {
            infoSymbolPopover.classList.remove('show');
            infoSymbolPopover.setAttribute('aria-hidden', 'true');
            currentInfoIcon = null;
          }
        }
      });

      function selectColor(color) {
        currentColor = color;
        updateColorDisplay();
        updateColor();

        // Update selected state
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.classList.toggle('selected', option.dataset.color === color);
        });

        // Save to localStorage
        localStorage.setItem('sf-color', color);
      }

      function updateColorDisplay() {
        const colorSelected = document.getElementById('color-selected');
        if (currentColor === 'currentColor') {
          // Visual indicator for theme-aware selection
          colorSelected.style.background = 'transparent';
          colorSelected.style.border = '2px dashed rgba(0,0,0,0.12)';
          colorSelected.textContent = 'T';
          colorSelected.style.color = 'inherit';
        } else {
          colorSelected.style.background = currentColor;
          colorSelected.style.border = '';
          colorSelected.textContent = '';
        }
      }

      function closeColorDropdown() {
        document.getElementById('color-selector').classList.remove('open');
      }

      // Update symbol color
      function updateColor() {
        // If using the special 'currentColor' token, set the CSS custom property
        // to the literal 'currentColor' so SVGs inherit the theme-aware color.
        if (currentColor === 'currentColor') {
          document.documentElement.style.setProperty('--symbol-color', 'currentColor');
        } else {
          document.documentElement.style.setProperty('--symbol-color', currentColor);
        }
        updateThemeIcon(document.body.classList.contains('dark-mode') ? 'dark' : 'light');
      }

      /**
       * Render drawer content depending on selection state.
       */
      function renderDrawerContent() {
        const container = document.getElementById('drawer-content');
        if (!container) return;
        container.innerHTML = '';
        // mark empty state class for vertical centering when nothing selected
        container.classList.toggle('empty', !selectedSymbolKey);

        if (!selectedSymbolKey) {
          // Empty view centered
          const emptyWrap = document.createElement('div');
          emptyWrap.style.height = '100%';
          emptyWrap.style.display = 'flex';
          emptyWrap.style.flexDirection = 'column';
          emptyWrap.style.alignItems = 'center';
          emptyWrap.style.justifyContent = 'center';
          emptyWrap.style.textAlign = 'center';
          emptyWrap.style.color = 'inherit';

          // questionmark icon
          const qKey = 'questionmark.app.dashed';
          const iconEl = document.createElement('div');
          iconEl.style.marginBottom = '0.6rem';
          if (currentData[qKey]) {
            const vb = currentViewBox[qKey] || '0 0 24 24';
            iconEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}" fill="currentColor" width="64" height="64">${currentData[qKey]}</svg>`;
          } else {
            iconEl.textContent = '?';
            iconEl.style.fontSize = '64px';
          }

          const titleEl = document.createElement('div');
          titleEl.style.marginTop = '8px';
          titleEl.style.fontWeight = '600';
          titleEl.textContent = 'No SF Symbol selected';

          emptyWrap.appendChild(iconEl);
          emptyWrap.appendChild(titleEl);
          container.appendChild(emptyWrap);
          return;
        }

        // Selected view - horizontal layout: preview | labels | codebox
        const displayName = (globalThis.symbolNames || {})[selectedSymbolKey] || selectedSymbolKey;
        const contentWrap = document.createElement('div');
        contentWrap.className = 'drawer-selected';
        contentWrap.style.width = '100%';
        contentWrap.style.paddingTop = '0';

        // Left: framed preview
        const leftCol = document.createElement('div');
        leftCol.className = 'drawer-left';
        leftCol.style.flex = '0 0 140px';
        leftCol.style.display = 'flex';
        leftCol.style.flexDirection = 'column';
        leftCol.style.alignItems = 'center';
        leftCol.style.justifyContent = 'center';

        const previewBox = document.createElement('div');
        previewBox.style.width = '180px';
        previewBox.style.height = '180px';
        previewBox.style.border = '1px solid rgba(0,0,0,0.12)';
        previewBox.style.borderRadius = '8px';
        previewBox.style.display = 'flex';
        previewBox.style.alignItems = 'center';
        previewBox.style.justifyContent = 'center';
        // 40px margin around the SF Symbol inside the preview box
        previewBox.style.padding = '40px';
        previewBox.style.boxSizing = 'border-box';
        previewBox.style.background = 'transparent';

        const svgKey = selectedSymbolKey;
        if (currentData[svgKey]) {
          const vb = currentViewBox[svgKey] || '0 0 24 24';
          // Always force fill for consistency
          const shouldForcePreviewFill = true;
          previewBox.innerHTML = shouldForcePreviewFill
            ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}" fill="${currentColor}" width="100%" height="100%">${currentData[svgKey]}</svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}" width="100%" height="100%">${currentData[svgKey]}</svg>`;
        } else {
          previewBox.textContent = 'SFSym';
          previewBox.style.fontSize = '18px';
          previewBox.style.color = 'inherit';
        }

        leftCol.appendChild(previewBox);

        // Middle: labels and values
        const infoCol = document.createElement('div');
        infoCol.className = 'drawer-info';
        infoCol.style.flex = '1 1 auto';
        infoCol.style.display = 'flex';
        infoCol.style.flexDirection = 'column';
        infoCol.style.gap = '8px';
        infoCol.style.fontSize = '0.95rem';
        // vertically center the text group relative to the preview symbol
        infoCol.style.justifyContent = 'center';

        const pkgLabel = document.createElement('div');
        pkgLabel.className = 'drawer-label';
        pkgLabel.textContent = 'Package Symbol Name';
        const pkgValue = document.createElement('div');
        pkgValue.textContent = displayName;
        pkgValue.style.fontSize = '1.3rem';
        pkgValue.style.fontWeight = 'bold';
        pkgValue.style.lineHeight = '1.2';

        const appleLabel = document.createElement('div');
        appleLabel.className = 'drawer-label';
        appleLabel.textContent = 'Apple Symbol Name';
        const appleValue = document.createElement('div');
        appleValue.textContent = selectedSymbolKey;
        appleValue.style.fontSize = '1.3rem';
        appleValue.style.fontWeight = 'bold';
        appleValue.style.lineHeight = '1.2';

        // Build rows with copy buttons for package and apple names
        function makeCopyButton(copyText, titleText, toastText) {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'drawer-copy-btn btn btn-sm';
          btn.style.width = '36px';
          btn.style.height = '28px';
          btn.title = titleText;
          btn.setAttribute('aria-label', titleText);

          // Try to render the SF Symbol 'document.on.clipboard.fill' from the loaded data if available,
          // otherwise fall back to a Bootstrap icon.
          const sfKey = 'document.on.clipboard.fill';
          if (currentData && currentData[sfKey]) {
            const vb = currentViewBox[sfKey] || '0 0 24 24';
            const svgSpan = document.createElement('span');
            svgSpan.style.display = 'inline-flex';
            svgSpan.style.width = '18px';
            svgSpan.style.height = '18px';
            svgSpan.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${vb}\" fill=\"currentColor\" width=\"18\" height=\"18\">${currentData[sfKey]}</svg>`;
            btn.appendChild(svgSpan);
          } else {
            btn.innerHTML = '<i class="bi bi-clipboard" aria-hidden="true" style="font-size:16px; line-height:1;"></i>';
          }

          btn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            navigator.clipboard.writeText(copyText).then(() => {
              showToast((toastText) ? toastText : (copyText + ' copied to clipboard'), 3000);
            }).catch(() => {
              showToast('Failed to copy', 3000);
            });
          });

          return btn;
        }

        // Package row
        const pkgRow = document.createElement('div');
        pkgRow.style.display = 'flex';
        pkgRow.style.alignItems = 'center';
        pkgRow.style.justifyContent = 'space-between';

        const pkgLeft = document.createElement('div');
        pkgLeft.appendChild(pkgLabel);
        pkgLeft.appendChild(pkgValue);

        const pkgCopyBtn = makeCopyButton(displayName, 'Copy Package Symbol Name to Clipboard');
        pkgRow.appendChild(pkgLeft);
        pkgRow.appendChild(pkgCopyBtn);

        // Apple row
        const appleRow = document.createElement('div');
        appleRow.style.display = 'flex';
        appleRow.style.alignItems = 'center';
        appleRow.style.justifyContent = 'space-between';

        const appleLeft = document.createElement('div');
        appleLeft.appendChild(appleLabel);
        appleLeft.appendChild(appleValue);

        const appleCopyBtn = makeCopyButton(selectedSymbolKey, 'Copy Apple Symbol Name to Clipboard');
        appleRow.appendChild(appleLeft);
        appleRow.appendChild(appleCopyBtn);

        infoCol.appendChild(pkgRow);
        infoCol.appendChild(appleRow);

        // Right: code box placeholder
        const codeCol = document.createElement('div');
        codeCol.className = 'drawer-code codebox-bg';
        codeCol.style.flex = '0 0 50%';
        codeCol.style.borderRadius = '0';
        codeCol.style.padding = '12px';
        codeCol.style.minHeight = '88px';
        codeCol.style.boxSizing = 'border-box';
        codeCol.style.background = 'transparent';
        // make codeCol itself non-scrolling; create an inner scroll container so the copy button can stay fixed
        codeCol.style.overflow = 'visible';
        codeCol.style.margin = '0';

        const codeInner = document.createElement('pre');
        codeInner.style.fontFamily = 'monospace';
        codeInner.style.fontSize = '0.9rem';
        codeInner.style.lineHeight = '1.4';
        codeInner.style.margin = '0';

        // Build example code with the selected package symbol name
        const importedName = displayName || 'SelectedSymbol';
        const exampleCode = `import { SFSymbol, ${importedName} } from 'sf-symbols-lib/hierarchical';

function MyComponent() {
  return (
    <div>
      {/* Basic usage */}
      <SFSymbol name={${importedName}} />

      {/* With size */}
      <SFSymbol name={${importedName}} size={32} />

      {/* With size preset */}
      <SFSymbol name={${importedName}} size="lg" />

      {/* Color via CSS */}
      <SFSymbol name={${importedName}} className="text-red-500" />

      {/* Inline style */}
      <SFSymbol name={${importedName}} style={{ color: '#ff0000' }} />

      {/* With CSS variable */}
      <SFSymbol name={${importedName}} style={{ color: 'var(--accent-color)' }} />

      {/* Icon button */}
      <button className="icon-button">
        <SFSymbol name={${importedName}} size={20} />
      </button>

      {/* Button with icon and text */}
      <button className="flex items-center gap-2">
        <SFSymbol name={${importedName}} size={16} />
        <span>Edit</span>
      </button>

      {/* Danger button */}
      <button className="flex items-center gap-2 text-red-500">
        <SFSymbol name={${importedName}} size={16} />
        <span>Delete</span>
      </button>
    </div>
  );
}
`;

        // Add line numbers
        const lines = exampleCode.split('\n');
        const numberedCode = lines.map((line, index) => `${(index + 1).toString().padStart(2, ' ')} ${line}`).join('\n');

        // Minimal syntax coloring with theme-aware CSS classes
        function escapeHtml(str) {
          // First decode any existing simple entities to avoid double-escaping
          str = str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
          // Preserve /> for JSX self-closing tags (use string replace to avoid escaping differences)
          str = str.split('/>').join('___SELF_CLOSE___');
          // Escape special chars (escape & first to avoid creating new entities)
          str = str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          str = str.split('___SELF_CLOSE___').join('/>');
          return str;
        }

        let highlighted = escapeHtml(numberedCode);

        // Protect HTML entities from being broken up by token regex
        highlighted = highlighted
          .replace(/&lt;/g, '___LT___')
          .replace(/&gt;/g, '___GT___')
          .replace(/&amp;/g, '___AMP___');

        // Combined token regex to avoid double-wrapping inserted spans
        const tokenPattern = new RegExp(
          [
            '(?<jsxcomment>\\{\\/[\\*][\\s\\S]*?[\\*]\\/\\})', // JSX block comment {/* ... */}
            '(?<blockcomment>\\/\\*[\\s\\S]*?\\*\\/)',
            '(?<linecomment>\\/\\/.*?$)',
            '(?<template>`(?:\\\\`|\\\\\\\\|[^`])*`)',
            "(?<single>'(?:\\\\'|\\\\\\\\|[^'])*')",
            '(?<double>"(?:\\\\\"|\\\\\\\\|[^\"])*")',
            '(?<jsxopen>___LT___\\/?)(?<jsxtag>[A-Za-z][\\w$-]*)(?=[\\s_\\/>])',
            '(?<property>\\s[a-zA-Z_][\\w-]*(?==))',
            '(?<number>\\b\\d+(?:\\.\\d+)?\\b)',
            '(?<constant>\\b(?:true|false|null|undefined)\\b)',
            '(?<keyword>\\b(?:import|from|function|return|const|let|if|else|for|while|switch|case|break|continue|class|extends|new|try|catch|finally|throw|await|async)\\b)',
            '(?<operator>[+\\-*/%=<>!&|^~?:]+)',
            '(?<punctuation>[()[\\]{}.,;])'
          ].join('|'),
          'gm'
        );

        highlighted = highlighted.replace(tokenPattern, (match, ...callbackArgs) => {
          const groups = callbackArgs[callbackArgs.length - 1] || {};
          if (groups.jsxcomment) return `<span class="syntax-comment">${groups.jsxcomment}</span>`;
          if (groups.blockcomment) return `<span class="syntax-comment">${groups.blockcomment}</span>`;
          if (groups.linecomment) return `<span class="syntax-comment">${groups.linecomment}</span>`;
          if (groups.template) return `<span class="syntax-string">${groups.template}</span>`;
          if (groups.single) return `<span class="syntax-string">${groups.single}</span>`;
          if (groups.double) return `<span class="syntax-string">${groups.double}</span>`;
          if (groups.jsxopen && groups.jsxtag) return `${groups.jsxopen}<span class="syntax-component">${groups.jsxtag}</span>`;
          // `groups.property` does not include the following '=' (lookahead), so do not append '=' here
          if (groups.property) return ' ' + '<span class="syntax-property">' + groups.property.trim() + '</span>';
          if (groups.number) return `<span class="syntax-number">${groups.number}</span>`;
          if (groups.constant) return `<span class="syntax-constant">${groups.constant}</span>`;
          if (groups.keyword) return `<span class="syntax-keyword">${groups.keyword}</span>`;
          if (groups.operator) return `<span class="syntax-operator">${groups.operator}</span>`;
          if (groups.punctuation) return `<span class="syntax-punctuation">${groups.punctuation}</span>`;
          return match;
        });

        // Restore HTML entities
        highlighted = highlighted
          .replace(/___LT___/g, '&lt;')
          .replace(/___GT___/g, '&gt;')
          .replace(/___AMP___/g, '&amp;');

        codeInner.innerHTML = highlighted;

        // Add copy button (use same styled button as drawer copy buttons)
        const codeCopyBtn = makeCopyButton(exampleCode, 'Copy Code to Clipboard', 'Code copied to clipboard');
        codeCopyBtn.style.position = 'absolute';
        codeCopyBtn.style.top = '8px';
        codeCopyBtn.style.right = '8px';
        codeCopyBtn.style.zIndex = '10';
        // ensure the button does not interfere with clicking the code area
        codeCopyBtn.addEventListener('click', (ev) => ev.stopPropagation());

        // Create inner scroll container for the code so the absolute button stays fixed
        const codeScroll = document.createElement('div');
        codeScroll.style.overflow = 'auto';
        codeScroll.style.height = '100%';
        codeScroll.style.boxSizing = 'border-box';
        codeScroll.appendChild(codeInner);

        codeCol.appendChild(codeCopyBtn);
        codeCol.appendChild(codeScroll);

        contentWrap.appendChild(leftCol);
        contentWrap.appendChild(infoCol);
        contentWrap.appendChild(codeCol);

        container.appendChild(contentWrap);
      }

      // Make renderDrawerContent globally accessible for the loader
      globalThis.renderDrawerContent = renderDrawerContent;

      // Event listeners
      variantSelect.addEventListener('change', updateData);
      const debouncedRender = debounce(renderSymbols, 160);
      searchInput.addEventListener('input', debouncedRender);

      // Drawer control helpers: open/close drawer programmatically
      function openDrawer() {
        document.body.classList.add('drawer-open');
        bottomDrawer.setAttribute('aria-hidden', 'false');
      }

      function closeDrawer() {
        document.body.classList.remove('drawer-open');
        bottomDrawer.setAttribute('aria-hidden', 'true');
        // clear visual selection
        document.querySelectorAll('.card.selected').forEach(node => node.classList.remove('selected'));
      }

      // Keyboard navigation and drawer controls
      document.addEventListener('keydown', (event) => {
        // Cmd/Ctrl+C to open copy modal when symbol is selected
        if ((event.metaKey || event.ctrlKey) && event.key === 'c' && selectedSymbolKey) {
          event.preventDefault();
          openCopyModal();
          return;
        }

        // Cmd/Ctrl+F to focus search field
        if ((event.metaKey || event.ctrlKey) && event.key === 'f') {
          event.preventDefault();
          searchInput.focus();
          searchInput.select();
          return;
        }

        // Escape key handling
        if (event.key === 'Escape' || event.key === 'Esc') {
          // If in search field and it's empty, blur the field
          if (document.activeElement === searchInput && searchInput.value === '') {
            searchInput.blur();
            return;
          }
          // Close drawer if open
          if (selectedSymbolKey) {
            selectedSymbolKey = null;
            renderDrawerContent();
            closeDrawer();
          }
          return;
        }

        // Don't navigate when in input field or modal is open
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
        if (copyModalOverlay.classList.contains('show')) return;

        const cards = getVisibleCards();
        if (cards.length === 0) return;

        const cols = getGridColumns();

        switch (event.key) {
          case 'ArrowRight':
            event.preventDefault();
            if (focusedIndex < 0) setFocusedCard(getCenteredCardIndex());
            else if (focusedIndex < cards.length - 1) setFocusedCard(focusedIndex + 1);
            break;

          case 'ArrowLeft':
            event.preventDefault();
            if (focusedIndex < 0) setFocusedCard(getCenteredCardIndex());
            else if (focusedIndex > 0) setFocusedCard(focusedIndex - 1);
            break;

          case 'ArrowDown':
            event.preventDefault();
            if (focusedIndex < 0) setFocusedCard(getCenteredCardIndex());
            else if (focusedIndex + cols < cards.length) setFocusedCard(focusedIndex + cols);
            break;

          case 'ArrowUp':
            event.preventDefault();
            if (focusedIndex < 0) setFocusedCard(getCenteredCardIndex());
            else if (focusedIndex - cols >= 0) setFocusedCard(focusedIndex - cols);
            break;

          case 'Enter':
            event.preventDefault();
            if (focusedIndex >= 0 && focusedIndex < cards.length) {
              cards[focusedIndex].click();
            }
            break;
        }
      });

      // Initialize color selector (will be called after saved state is restored)

      // Load data
      try {
        const module = await import('./sf-symbols-data.js');

        allSymbolsData = module.sfSymbolsData || {};
        allViewBoxData = module.sfSymbolsViewBox || {};
        symbolNames = module.sfSymbolNames || {};

        // Restore saved variant and color
        const savedVariant = localStorage.getItem('sf-variant') || 'hierarchical';
        // If no saved color exists yet, default to theme-aware `currentColor`
        const savedColorRaw = localStorage.getItem('sf-color');
        const savedColor = (savedColorRaw !== null) ? savedColorRaw : 'currentColor';
        variantSelect.value = savedVariant;
        currentColor = savedColor;

        // Apply initial color
        updateColor();

        // Save selection on change
        variantSelect.addEventListener('change', () => localStorage.setItem('sf-variant', variantSelect.value));

        updateData();

        // Initialize color selector after restoring saved color so selected state shows correctly
        initColorSelector();
        // After data is loaded, prefer SF Symbol `InfoBubble` for the About button if available
        (function setAboutButtonIcon() {
          const aboutBtnIconEl = document.getElementById('about-button-icon');
          const aboutBtn = document.getElementById('about-button');
          if (!aboutBtnIconEl || !aboutBtn) return;
          const candidateKeys = ['info.bubble', 'info.bubble.fill', 'info.bubble.circle', 'infoBubble'];
          let replaced = false;
          for (const candidate of candidateKeys) {
            if (currentData && currentData[candidate]) {
              const vb = currentViewBox[candidate] || '0 0 24 24';
              aboutBtnIconEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}" fill="currentColor" width="18" height="18">${currentData[candidate]}</svg>`;
              replaced = true;
              break;
            }
          }
          if (!replaced) {
            // keep bootstrap fallback (info-square)
            aboutBtnIconEl.innerHTML = '<i class="bi bi-info-square" aria-hidden="true" style="font-size:18px; line-height:1;"></i>';
          }
        })();
      } catch (error) {
        iconsContainer.innerHTML = `<div class="p-4 text-danger">Error loading symbols: ${error.message}</div>`;
        console.error('Failed to load symbols data:', error);
      }
    </script>

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>
